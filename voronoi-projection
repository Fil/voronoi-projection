#!/usr/bin/env node --max-old-space-size=4096

const fs = require("fs"),
  topojson = require("topojson-client"),
  Canvas = require("canvas"),
  d3 = Object.assign(
    {},
    require("d3-array"),
    require("d3-geo"),
    require("d3-geo-voronoi"),
    require("d3-geo-polygon")
  ),
  radians = Math.PI / 180;

const commander = require("commander");

commander
  .version(require("./package.json").version)
  .usage("[options]")
  .description("Generate a Voronoi map.")
  .option("-n, --n <value>", "number of faces; defaults to " + 200, 200)
  .option("-w, --width <value>", "width", 2 * 960)
  .option("-h, --height <value>", "width", null)
  .option("--graticule", "show graticule", false)
  .option(
    "--land <value>",
    "strategy for land (auto, full, point, poly, none)",
    "auto"
  )
  .option("--ocean", "favor ocean links", false)
  .option("--fibonacci", "fibonacci distribution", false)
  .option("--centroids", "large countries centroids distribution", false)
  .option("--noise <value>", "perturbation (try: 1)", 0)
  .parse(process.argv);

var width = +commander.width,
  height = +commander.height || ((3 / 5) * width) | 0;

var canvas = new Canvas(width, height),
  context = canvas.getContext("2d");

var world = require("visionscarto-world-atlas/world/110m.json"),
  land = topojson.feature(world, world.objects.land),
  countries = topojson.feature(world, world.objects.countries),
  graticule = d3.geoGraticule(),
  outline = { type: "Sphere" };

const n = +commander.n,
  ocean = !!commander.ocean,
  pointdistribution = commander.centroids
    ? centroids
    : commander.fibonacci
      ? fibonacci
      : randompoints;

var time = Date.now();

randomseed(4);

process.stderr.write("computing points… ");

const points = pointdistribution(n);
points.forEach((p, i) => {
  p[2] = i;
});

if (commander.noise) {
  const perturb = +commander.noise / Math.sqrt(n);
  points.forEach((p, i) => {
    p[0] += ((Math.random() - 0.5) * perturb * 180) / Math.cos(p[1] * radians);
    p[1] = (p[1] + (Math.random() - 0.5) * perturb * 180) % 90;
  });
}

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("computing voronoi… ");

const voro = d3.geoVoronoi()(points);

const polygons = voro.polygons();

// this gains 99% on the computation of points.property.land
// const contains = (f => d3.geoContains(land,f));
console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("computing distances… ");

const contains = geoContainsCache(land),
  inland = points.map(d => +contains(d)),
  shore = points.map(dist2shore());

function cost2(a, b) {
  var mult = (1 + shore[a[2]]) ** 2 * (1 + shore[b[2]]) ** 2;
  if (ocean) mult = 1 / mult;
  return d3.geoDistance(a, b) / mult;
}

const kruskal = (function() {
  // https://github.com/mikolalysenko/union-find
  const UnionFind = (function() {
    "use strict";
    "use restrict";

    function UnionFind(count) {
      this.roots = new Array(count);
      this.ranks = new Array(count);

      for (var i = 0; i < count; ++i) {
        this.roots[i] = i;
        this.ranks[i] = 0;
      }
    }

    var proto = UnionFind.prototype;

    Object.defineProperty(proto, "length", {
      get: function() {
        return this.roots.length;
      }
    });

    proto.makeSet = function() {
      var n = this.roots.length;
      this.roots.push(n);
      this.ranks.push(0);
      return n;
    };

    proto.find = function(x) {
      var x0 = x;
      var roots = this.roots;
      while (roots[x] !== x) {
        x = roots[x];
      }
      while (roots[x0] !== x) {
        var y = roots[x0];
        roots[x0] = x;
        x0 = y;
      }
      return x;
    };

    proto.link = function(x, y) {
      var xr = this.find(x),
        yr = this.find(y);
      if (xr === yr) {
        return;
      }
      var ranks = this.ranks,
        roots = this.roots,
        xd = ranks[xr],
        yd = ranks[yr];
      if (xd < yd) {
        roots[xr] = yr;
      } else if (yd < xd) {
        roots[yr] = xr;
      } else {
        roots[yr] = xr;
        ++ranks[xr];
      }
    };

    return UnionFind;
  })();

  function kruskal(graph, dist) {
    // 1   A := ø
    const A = [];
    // 2   pour chaque sommet v de G :
    // 3      créerEnsemble(v)
    let n = -Infinity;
    graph.forEach(l => {
      if (l.source.index > n) n = l.source.index;
      if (l.target.index > n) n = l.target.index;
    });

    const uf = new UnionFind(n);
    // 4   trier les arêtes de G par poids croissant

    graph = graph.map(l => {
      l.w = dist ? dist(l.source, l.target) : l.length;
      return l;
    });
    graph
      .sort((a, b) => d3.ascending(a.w, b.w))
      // 5   pour chaque arête (u, v) de G prise par poids croissant :
      .forEach(l => {
        // 6      si find(u) ≠ find(v) :
        if (uf.find(l.source.index) != uf.find(l.target.index)) {
          // 7         ajouter l'arête (u, v) à l'ensemble A
          A.push(l);
          // 8         union(u, v)
          uf.link(l.source.index, l.target.index);
        }
      });
    // 9   retourner A
    return A;
    //	yield uf;
  }

  return kruskal;
})();

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("computing tree… ");
const parents = (function() {
  var n = points.length;

  var links = voro.links().features.map(d => d.properties); //.filter(d => d.urquhart)

  var k = kruskal(
    links.map(
      d => ((d.source.index = d.source[2]), (d.target.index = d.target[2]), d)
    ),
    cost2
  ).map(l => ({
    type: "LineString",
    coordinates: [l.source, l.target],
    properties: l
  }));

  // Build a tree of the faces
  var parents = [-1];
  var search = n - 1;
  do {
    k.forEach(l => {
      var s = l.properties.source[2],
        t = l.properties.target[2];
      if (parents[s] !== undefined && parents[t] === undefined) {
        parents[t] = s;
        search--;
      } else if (parents[t] !== undefined && parents[s] === undefined) {
        parents[s] = t;
        search--;
      }
    });
  } while (search > 0);

  return parents;
})();

const degrees = 180 / Math.PI;

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("computing projection… ");
const projection = d3
  .geoPolyhedralVoronoi(parents, polygons, null, voro.find)
  .angle(-10)
  .fitExtent([[3, 3], [width - 3, height - 3]], { type: "Sphere" });

var path = d3
  .geoPath()
  .projection(projection)
  .context(context);

context.fillStyle = "#fff";
context.fillRect(0, 0, width, height);

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("projecting sphere… ");
context.beginPath();
path({ type: "Sphere" });
context.fillStyle = "#fefef6";
context.fill();

if (commander.land === "auto") commander.land = n < 1000 ? "full" : "poly";

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("projecting land… ");
context.beginPath();
switch (commander.land) {
  case "full":
    path(land);
    break;
  case "point":
    path.pointRadius(Math.sqrt(300000 / n));
    points.forEach(p => contains(p) && path({ type: "Point", coordinates: p }));
    break;

  case "poly":
    const preclip = projection.preclip();
    projection.preclip(s => s);
    context.beginPath();
    points.forEach(
      (p, i) => contains(p) && path(shrink(polygons.features[i].geometry))
    );
    projection.preclip(preclip);
    break;

  case "none":
    break;
}
context.fillStyle = "#000";
context.fill();

if (commander.graticule) {
  console.warn(Date.now() - time);
  time = Date.now();
  process.stderr.write("projecting graticule… ");
  context.beginPath();
  path(graticule());
  context.strokeStyle = "rgba(119,119,119,0.5)";
  context.stroke();
}

console.warn(Date.now() - time);
time = Date.now();
process.stderr.write("projecting sphere… ");
context.beginPath();
path({ type: "Sphere" });
context.strokeStyle = "#000";
context.stroke();

console.warn(Date.now() - time);
time = Date.now();
canvas.pngStream().pipe(process.stdout);

////

// https://beta.observablehq.com/@fil/another-hex-map#geoContainsCache
function geoContainsCache(land) {
  var w = 5000,
    h = 5000,
    projection = d3.geoAzimuthalEqualArea().fitSize([w, h], { type: "Sphere" }),
    canvas = new Canvas(w, h),
    context = canvas.getContext("2d"),
    path = d3.geoPath(projection, context);
  canvas.width = w;
  canvas.height = h;
  context.fillStyle = "white";
  context.fillRect(0, 0, w, h);
  context.fillStyle = "black";
  context.beginPath(), path(land), context.fill();
  var c = context.getImageData(0, 0, w, h).data;
  canvas = context = path = null; // free up memory
  return function(point) {
    point = projection(point);
    return c[4 * (Math.floor(point[0]) + Math.floor(point[1]) * w)] < 128;
  };
}

function dist2shore() {
  const vertices = geoVertices(land),
    delaunay = d3.geoDelaunay(vertices);
  return function(a) {
    return (
      d3.geoDistance(a, vertices[delaunay.find(a[0], a[1])]) *
      (contains(a) ? 1 : -1)
    );
  };
}

// point distribution functions
function randompoints(n) {
  return [[0, 0]].concat(
    d3
      .range(n - 1)
      .map(i => [
        360 * Math.random() - 180,
        90 * (Math.random() - Math.random())
      ])
  );
}

function fibonacci(n) {
  const phi = (1 + Math.sqrt(5)) / 2;
  return d3.range(n).map(i => {
    const x = i / phi,
      y = i / n;
    return [
      ((x * 360) % 360) - 180,
      (Math.acos(2 * y - 1) / Math.PI) * 180 - 90
    ];
  });
}

function centroids(n) {
  return countries.features
    .slice()
    .sort((a, b) => d3.geoArea(b) - d3.geoArea(a))
    .slice(0, n)
    .map(d3.geoCentroid);
}

function randomseed(k) {
  Math.seed = function(s) {
    return function() {
      s = Math.sin(s) * 10000;
      return s - Math.floor(s);
    };
  };
  Math.random = Math.seed(k);
}

function geoVertices(feature) {
  const vertices = [];
  const stream = {
    point: function(lambda, phi) {
      vertices.push([lambda, phi]);
    },
    lineStart: function() {},
    lineEnd: function() {},
    polygonStart: function() {},
    polygonEnd: function() {}
  };
  d3.geoStream(feature, stream);
  return vertices;
}

function shrink(polygon) {
  const c = d3.geoCentroid(polygon);
  return {
    type: "Polygon",
    coordinates: [
      polygon.coordinates[0].map(d => d3.geoInterpolate(d, c)(0.01))
    ]
  };
}
